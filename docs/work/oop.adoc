= 物件導向特性

== 類別/物件
將實體的相關屬性和互動 *模型化/抽象化* 為類別； +
透過類別來定義抽象概念，透過 *new* 來實體化抽象概念(即創立物件)。

```
//抽象定義, 為資料互動方式建立模型
public class BankAccount
{
    public string Number { get; }
    public string Owner { get; set; }
    public decimal Balance { get; }
}

//實體化時被分配主記憶體空間
BankAccount myAccount = new BankAccount();
```

== 封裝
隱藏物件的內部狀態和功能，並且只允許透過公用函式集進行存取。

```
    public class BankAccount
    {
        public string Number { get; set; }
        public string Owner { get; set; }
        public decimal Balance
        {
            get
            {
                decimal balance = 0;
                //要取得餘額時, 透過交易紀錄計算
                foreach (var item in _allTransactions)
                {
                    balance += item.Amount;
                }

                return balance;
            }
        }

        private static int _accountNumberSeed = 1234567890;

        // 交易紀錄被封裝, 外部無法直接存取
        private List<Transaction> _allTransactions = [];

        // 外部需透過允許的開放方法取得
        public string GetAccountHistory()
        {
            var report = new System.Text.StringBuilder();

            decimal balance = 0;
            report.AppendLine("Date\t\tAmount\tBalance\tNote");
            foreach (var item in _allTransactions)
            {
                balance += item.Amount;
                report.AppendLine($"{item.Date.ToShortDateString()}\t{item.Amount}\t{balance}\t{item.Notes}");
            }

            return report.ToString();
        }

        ...

    }

```

封裝的特性令資料存取的設計更為彈性、隱蔽: +

. 防止外部輕易更動關鍵數值
. 修改前必須經過某種換算或加密
. 讀取時經過遮蔽或解密

== 繼承
能夠根據現有的抽象概念建立新的抽象概念； +
透過繼承現有的類別獲取共同的模型結構，提高函式的覆用性。

Note: 介面可連續繼承。

```
public class InterestEarningAccount : BankAccount
{
}

public class GiftCardAccount : BankAccount
{
}
```

```
public class InterestEarningAccount : BankAccount
{
    //base: 用基礎類別的建構子來實體化
    public InterestEarningAccount(string name, decimal initialBalance) : base(name, initialBalance){}

}

當實體化 InterestEarningAccount 物件時，該物件也會擁有 BankAccount 的屬性與方法。

```


== 多型
能夠跨多個抽象概念以不同方式實作繼承的屬性或方法。 +
在基礎類別中定義 virture 方法，可在子類別覆寫，定義子類別的特定行為。

```
public class BankAccount
{
    ...

    // 從基礎類別定義共用方法
    public virtual void PerformMonthEndTransactions() { }
    
    // Note: virtual 的方法可有預設行為，衍生類別可選擇是否發展出特定行為。
}


public class InterestEarningAccount : BankAccount
{
    ...
    // override 覆寫基類方法
    public override void PerformMonthEndTransactions()
    {
        if (Balance > 500m)
        {
            decimal interest = Balance * 0.02m;
            MakeDeposit(interest, DateTime.Now, "apply monthly interest");
        }
    }
}

```


== 參考資料
https://learn.microsoft.com/zh-tw/dotnet/csharp/fundamentals/tutorials/classes +
https://learn.microsoft.com/zh-tw/dotnet/csharp/fundamentals/tutorials/oop
